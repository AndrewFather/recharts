#' Create an axis for a chart
#'
#' Add an axis to a chart.
#'
#' This function modified a few default options for the axis component in
#' ECharts: 1) \code{scale = TRUE} (was \code{FALSE} by default in ECharts); 2)
#' \code{axisLine$onZero = FALSE} (was \code{TRUE} in ECharts).
#' @export
#' @rdname axis
eAxis = function(
  chart, which = c('x', 'y'),
  type = c('value', 'category', 'time'), show = TRUE,
  position = c('bottom', 'top', 'left', 'right'),
  name = '', nameLocation = c('end', 'start'), nameTextStyle = emptyList(),
  boundaryGap = c(0, 0), min = NULL, max = NULL, scale = TRUE, splitNumber = NULL,
  axisLine = list(show = TRUE, onZero = FALSE), axisTick = list(show = FALSE),
  axisLabel = list(show = TRUE), splitLine = list(show = TRUE),
  splitArea = list(show = FALSE), data = list()
) {
  which = match.arg(which)
  odata = getMeta(chart)[[which]]  # original data along the axis
  if (missing(type)) type = axisType(odata, which)
  if (missing(position)) position = if (which == 'x') 'bottom' else 'left'
  if (missing(data) && type == 'category') {
    data = I(levels(as.factor(odata)))
  }

  x = chart$x
  i = paste0(which, 'Axis')
  o = list(
    type = match.arg(type), show = show, position = match.arg(position),
    name = name, nameLocation = match.arg(nameLocation), nameTextStyle = nameTextStyle,
    boundaryGap = boundaryGap, min = min, max = max, scale = scale,
    splitNumber = splitNumber, axisLine = axisLine, axisTick = axisTick,
    axisLabel = axisLabel, splitLine = splitLine, splitArea = splitArea, data = data
  )
  if (length(x[[i]])) {
    # only merge the arguments that are not missing, e.g. eAxis(min = 0) will
    # only override 'min' but will not override the 'name' attribute
    a = intersect(names(as.list(match.call()[-1])), names(o))#;browser()
    x[[i]] = mergeList(x[[i]], o[a])
  } else {
    x[[i]] = mergeList(x[[i]], o)
  }
  chart$x = x

  chart
}

#' @export
#' @rdname axis
eXAxis = function(chart, ...) {
  eAxis(chart, which = 'x', ...)
}

#' @export
#' @rdname axis
eYAxis = function(chart, ...) {
  eAxis(chart, which = 'y', ...)
}

axisType = function(data, which = c('x', 'y')) {
  if (is.numeric(data) || is.null(data)) return('value')
  if (is.factor(data) || is.character(data)) return('category')
  if (inherits(data, 'Date')) return('time')
  message('The structure of the ', which, ' variable:')
  str(data)
  stop('Unable to derive the axis type automatically from the ', which, ' variable')
}

makeTitle <- function(title=NULL, subtitle=NULL, link=NULL,
                      sublink=NULL, pos=6, ...){
    # Work function for setTitle
    title <- ifelse(is.null(title), "", title)
    subtitle <- ifelse(is.null(subtitle), "", subtitle)
    if (grepl("^\\[.+\\]\\(.+\\)$", title)){
        link <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\2", title)
        title <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\1", title)
    }
    if (grepl("^\\[.+\\]\\(.+\\)$", subtitle)){
        sublink <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\2", subtitle)
        subtitle <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\1", subtitle)
    }
    lstTitle <- list(text=title, subtext=subtitle)
    lstTitle[['x']] <- vecPos(pos)[1]
    lstTitle[['y']] <- vecPos(pos)[2]
    lstTitle[['orient']] <- vecPos(pos)[3]
    if (!is.null(link)) lstTitle[['link']] <- link
    if (!is.null(sublink)) lstTitle[['sublink']] <- sublink
    # if (!is.null(z)) lstTitle[['text']] <-
    #     paste0(lstTitle[['text']], " (",zvar," = ",timeslice[t],")")
    return(lstTitle)
}

#' Set \code{title} (And Subtitle) of Echarts
#'
#' When an echart object is generated, you can modify it by setting title and
#' subtitles using \%>\%.
#' @param chart \code{echart} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param title text of the title. If written in markdown format \code{[caption](url)},
#' then \code{caption} is passed to title, \code{url} is passed to link. If the length
#' of the title vector equals to the length of timeline slices, the title vector will
#' be used as slice-specific user-defined title.
#' @param link link of the title
#' @param subtitle text of the subtitle. If written in markdown format \code{[caption](url)},
#' then \code{caption} is passed to title, \code{url} is passed to link. If the length
#' of the subtitle vector equals to the length of timeline slices, the subtitle vector will
#' be used as slice-specific user-defined title.
#' @param sublink link of the subtitle
#' @param pos the clock-position of title (and subtitle), refer to \code{\link{vecPos}}
#' @param ... elipsis
#'
#' @return A modified echart object
#' @export
#'
#' @references
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~title}
#'
#' @examples
#' \dontrun{
#' ## simple echarts scatter plot
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#'
#' ## set simple titles
#' g %>% setTitle(title='Iris data set', subtitle='by: R. A. Fisher')
#'
#' ## set titles with links
#' g %>% setTitle(
#'   '[Iris data set](https://en.wikipedia.org/wiki/Iris_flower_data_set)',
#'   '[R. A. Fisher](https://en.wikipedia.org/wiki/Ronald_Fisher)')
#'
#' ## echarts with timeline
#' g1 <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, z=Species, type='scatter')
#'
#' ## simple titles/subtitles
#' g1 %>% setTitle(
#'     '[Iris data set](https://en.wikipedia.org/wiki/Iris_flower_data_set)',
#'     '[R. A. Fisher](https://en.wikipedia.org/wiki/Ronald_Fisher)')
#'
#' ## user-defined titles/subtitles
#' titles <- c(
#'     '[Iris species 1](https://en.wikipedia.org/wiki/Iris_setosa)',
#'     '[Iris species versicolor](https://en.wikipedia.org/wiki/Iris_versicolor)',
#'     '[Iris species 3](https://en.wikipedia.org/wiki/Iris_virginica)')
#' g1 %>% setTitle(titles)
#' }
setTitle <- function(chart, title=NULL, subtitle=NULL, link=NULL,
                     sublink=NULL, pos=6, ...){
    stopifnot(inherits(chart, 'echarts'))
    if ('timeline' %in% names(chart$x)[1]){  # has a timeline
        if (!is.null(title)){
            if (length(title) == length(chart$x$options)){
                titles <- unlist(title)
            } else {
                if (grepl("^\\[.+\\]\\(.+\\)$", title[1])){
                    link <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\2", title[1])
                    title <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\1", title[1])
                }
                titles <- paste0(
                    rep(gsub("^\\[(.+)\\]\\((.+)\\)$", "\\1", title),
                        length(chart$x$options)), " (",
                    attr(chart$x$timeline, 'sliceby'), " = ",
                    chart$x$timeline$data, ")")
            }
        } else {
            titles <- rep(NULL, length(chart$x$options))
        }
        .dupicateThem <- function(val){
            if (!is.null(val)){
                if (length(val) == length(chart$x$options)){
                    return(as.vector(val))
                } else {
                    return(rep(val[1], length(chart$x$options)))
                }
            } else {
                return(rep(NULL, length(chart$x$options)))
            }
        }
        subtitles <- .dupicateThem(subtitle)
        links <- .dupicateThem(link)
        sublinks <- .dupicateThem(sublink)

        for (i in seq_len(length(chart$x$options))){
            if (! all(is.null(c(titles, subtitles, links, sublinks)))){
                chart$x$options[[i]]$title <- makeTitle(
                    titles[i], subtitles[i], links[i], sublink[i], pos[1])
            }
        }
    }else{  # do not have timeline
        if (! all(is.null(c(title, subtitle, link, sublink))))
            chart$x$title <- makeTitle(title, subtitle, link, sublink, pos[1])
    }
    return(chart)
}

makeToolbox <- function(toolbox=c(TRUE,'cn'), type='auto',
                        show=c('mark', 'dataZoom', 'dataView', 'magicType',
                               'restore', 'saveAsImage'), pos=1, ...){
    # Work function for setToolbox
    if (! is.null(show)) show <- tolower(show)
    if (toolbox[1]){
        lstToolbox= list(
            show = toolbox[1],
            feature = list(
                mark =list(show = ('mark' %in% show)),
                dataZoom = list(show = ('datazoom' %in% show)),
                dataView = list(show = ('dataview' %in% show),
                                readOnly = FALSE),
                magicType = list(show = FALSE),
                restore = list(show = ('restore' %in% show)),
                saveAsImage = list(show = ('saveasimage' %in% show))
            )
        )
        if (tolower(toolbox[2]) != 'cn'){  # Enlish tooltips of the controls
            lstToolbox[['feature']][['mark']][['title']] = list(
                mark="Apply Auxiliary Conductor",
                markUndo="Undo Auxiliary Conductor",
                markClear="Clear Auxiliary Conductor")
            lstToolbox[['feature']][['dataZoom']][['title']] = list(
                dataZoom="Data Zoom",
                dataZoomReset="Reset Data Zoom")
            lstToolbox[['feature']][['dataView']][['title']] = "Data View"
            lstToolbox[['feature']][['restore']][['title']] = "Restore"
            lstToolbox[['feature']][['saveAsImage']][['title']] = "Save As Image"
        }
        lstToolbox[c('x', 'y', 'orient')] <- vecPos(pos)

        if (type[1] %in% c('auto', 'line', 'bar', 'area', 'k', 'histogram')){
            lstToolbox[['feature']][['magicType']] <-
                list(show=TRUE, type= c('line', 'bar', 'tiled', 'stack'))
        }else if (type[1] %in% c('ring', 'pie', 'rose')){
            lstToolbox[['feature']][['magicType']] <-
                list(show=TRUE, type= c('pie', 'funnel'),
                     option=list(funnel=list(x='25%', width='80%',
                                             funnelAlign='center')))
        }else if (type[1] %in% c('force', 'chord')){
            lstToolbox[['feature']][['magicType']] <-
                list(show=TRUE, type= c('force', 'chord'))
            lstToolbox[['feature']][['dataView']] <- list(show=FALSE)
            lstToolbox[['feature']][['dataZoom']] <- list(show=FALSE)
        }
        if (lstToolbox$feature$magicType$show){
            if (tolower(toolbox[2]) != 'cn'){
                lstToolbox[['feature']][['magicType']][['title']] <- list(
                    line   = "Switch to Line Chart",
                    bar    = "Switch to Bar Chart",
                    stack  = "Stack",
                    tiled  = "Tiled",
                    force  = "Switch to Force Chart",
                    chord  = "Switch to Chord Chart",
                    pie    = "Switch to Pie Chart",
                    funnel = "Switch to Funnel Chart"
                )
            }
        }
    }else{
        lstToolbox=list(show=FALSE)
    }
    return(lstToolbox)
}

#' Set \code{toolbox} of Echarts
#'
#' When an echart object is generated, you can modify it by setting toolbox using \%>\%.
#' @param chart \code{echart} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show logical. Show the toolbox if TRUE.
#' @param language 'cn' or 'en', the language of the toolbox tooltips.
#' @param controls which widgets to show. Default \code{'mark', 'dataZoom', 'dataView', 'magicType',
#' 'restore', 'saveAsImage'}.
#' @param pos the clock-position of toolbox, refer to \code{\link{vecPos}}
#' @param ... elipsis
#'
#' @return A modified echart object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~toolbox}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setToolbox(TRUE, 'en')
#' }
setToolbox <- function(chart, show=TRUE, language='cn',
                       controls=c('mark', 'dataZoom', 'dataView', 'magicType',
                                  'restore', 'saveAsImage'), pos=1, ...){
    stopifnot(inherits(chart, 'echarts'))
    if ('timeline' %in% names(chart$x)){
        type <- chart$x$options[[1]]$series[[1]]$type
        chart$x$options[[1]]$toolbox <- makeToolbox(toolbox=c(show, language),
                                                    type, controls, pos)
    }else{
        type <- chart$x$series[[1]]$type
        chart$x$toolbox <- makeToolbox(toolbox=c(show, language),
                                       type, controls, pos)
    }
    return(chart)
}

#-----Palettes and others---------
#' Get The Colors Vector From A Named Palette
#'
#' Get hex color vector of a named palette from \code{\link{RColorBrewer}}, \code{\link{ggthemes}}
#' or \code{\link{grDevices}}. You can \code{\link{scale::show_col}} the vector to
#' see the effects.
#' @param palname name of the palette. Default NULL to get echarts default. Could be:
#' \itemize{
#'  \item \link{RColorBrewer} palettes: Including 'BrBG', 'PiYG', 'PRGn', 'PuOr', 'RdBu',
#'  'RdGy', 'RdYlBu', 'RdYlGn', 'Spectral', 'Accent', 'Dark2', 'Paired', 'Pastel1',
#'  'Pastel2', 'Set1', 'Set2', 'Set3', 'Blues', 'BuGn', 'BuPu', 'GnBu', 'Greens',
#'  'Greys', 'Oranges', 'OrRd', 'PuBu', 'PuBuGn', 'PuRd', 'Purples', 'RdPu', 'Reds',
#'  'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd' \cr
#'  \item \link{ggthemes} palettes: 'calc', 'economist', 'economist_white', 'economist_stata',
#'  'excel', 'exel_fill', 'excel_line', 'excel_new', 'few', 'fivethirtyeight', '538', 'manyeyes',
#'  'gdocs', 'pander', 'tableau', 'stata', 'stata1','stata1r','statamono', 'ptol',
#'  'tableau20', 'tableau10medium', 'tableaugray', 'tableauprgy', 'tableaublrd',
#'  'tableaugnor', 'tableaucyclic', 'tableau10light', 'tableaublrd12', 'tableauprgy12',
#'  'tableaugnor12', 'hc', 'darkunica', 'solarized', 'solarized_red', 'solarized_yellow',
#'  'solarized_orange', 'solarized_magenta', 'solarized_violet', 'solarized_blue',
#'  'solarized_cyan', 'solarized_green', 'wsj', 'wsj_rgby', 'wsj_red_green',
#'  'wsj_black_green', 'wsj_dem_rep', 'colorblind', 'trafficlight' \cr
#'  \item Aetna official palettes: Including 'aetnagreen', 'aetnablue', 'aetnaviolet',
#'  'aetnaorange', 'aetnateal', 'aetnacranberry' \cr
#'  \item Other palettes: 'rainbow', 'terrain', 'topo', 'heat', 'cm'
#' }
#' @param n length of the color vector when the palette is continuous (rain, cm,
#' terrain, topo, heat, ...). Default 6.
#' @import RColorBrewer scales ggthemes
#' @export
#' @return color vectors
#'
#' @seealso \code{\link{RColorBrewer}}, \code{\link{scales}}, \code{\link{ggthemes}},
#' \code{\link{show_col}}
#' @examples
#' \dontrun{
#' show_col(getColFromPal('tableau20'))
#' show_col(getColFromPal('hc'))
#' }
getColFromPal <- function(palname=NULL, n=6){
    brewer <- c('BrBG', 'PiYG', 'PRGn', 'PuOr', 'RdBu', 'RdGy', 'RdYlBu',
                'RdYlGn', 'Spectral', 'Accent', 'Dark2', 'Paired', 'Pastel1',
                'Pastel2', 'Set1', 'Set2', 'Set3', 'Blues', 'BuGn', 'BuPu',
                'GnBu', 'Greens', 'Greys', 'Oranges', 'OrRd', 'PuBu', 'PuBuGn',
                'PuRd', 'Purples', 'RdPu', 'Reds', 'YlGn', 'YlGnBu', 'YlOrBr',
                'YlOrRd')
    tableau <- data.frame(
        nick=c('tableau20', 'tableau10medium', 'tableaugray', 'tableauprgy',
               'tableaublrd', 'tableaugnor', 'tableaucyclic', 'tableau10light',
               'tableaublrd12', 'tableauprgy12', 'tableaugnor12', 'tableau',
               'tableaucolorblind', 'trafficlight'),
        pal=c('tableau20', 'tableau10medium', 'gray5', 'purplegray6',
              'bluered6', 'greenorange6', 'cyclic', 'tableau10light',
              'bluered12', 'purplegray12', 'greenorange12', 'tableau10',
              'colorblind10', 'trafficlight'))
    ## echarts default
    colObj <- c('#ff7f50', '#87cefa', '#da70d6', '#32cd32', '#6495ed',
                '#ff69b4', '#ba55d3', '#cd5c5c', '#ffa500', '#40e0d0',
                '#1e90ff', '#ff6347', '#7b68ee', '#00fa9a', '#ffd700',
                '#6b8e23', '#ff00ff', '#3cb371', '#b8860b', '#30e0e0' )
    if (! is.null(palname)) palname <- tolower(palname)
    if (! is.null(palname)){
        if (palname %in% paste0(
            "aetna", c('green','blue','teal','cranberry','orange','violet'))){
            colObj <- switch(
                palname,
                aetnagreen=c("#7AC143", "#7D3F98", "#F47721", "#D20962",
                             "#00A78E", "#00BCE4", "#B8D936", "#EE3D94",
                             "#FDB933", "#F58F9F", "#60C3AE", "#5F78BB",
                             "#5E9732", "#CEA979", "#EF4135", "#7090A5"),
                aetnablue=c("#00BCE4", "#D20962", "#7AC143", "#F47721",
                            "#7D3F98", "#00A78E", "#F58F9F", "#B8D936",
                            "#60C3AE", "#FDB933", "#EE3D94", "#5E9732",
                            "#5F78BB", "#CEA979", "#EF4135", "#7090A5"),
                aetnateal=c("#00A78E", "#F47721", "#7AC143", "#00BCE4",
                            "#D20962", "#7D3F98", "#60C3AE", "#FDB933",
                            "#B8D936", "#5F78BB", "#F58F9F", "#EE3D94",
                            "#5E9732", "#CEA979", "#EF4135", "#7090A5"),
                aetnacranberry=c("#D20962", "#00BCE4", "#7D3F98", "#7AC143",
                                 "#F47721", "#00A78E", "#F58F9F", "#60C3AE",
                                 "#EE3D94", "#B8D936", "#FDB933", "#5E9732",
                                 "#5F78BB", "#CEA979", "#EF4135", "#7090A5"),
                aetnaorange=c("#F47721", "#7AC143", "#00A78E", "#D20962",
                              "#00BCE4", "#7D3F98", "#FDB933", "#B8D936",
                              "#60C3AE", "#F58F9F", "#5F78BB", "#EE3D94",
                              "#5E9732", "#CEA979", "#EF4135", "#7090A5"),
                aetnaviolet=c("#7D3F98", "#7AC143", "#F47721", "#00A78E",
                              "#00BCE4", "#D20962", "#F58F9F", "#B8D936",
                              "#FDB933", "#60C3AE", "#5F78BB", "#EE3D94",
                              "#5E9732", "#CEA979", "#EF4135", "#7090A5")
            )
        }else if (palname %in% tolower(brewer)){
            Palname <- brewer[which(tolower(brewer)==palname)]
            maxcolors <- brewer.pal.info[row.names(brewer.pal.info)==Palname,
                                         "maxcolors"]
            colObj <- brewer.pal(ifelse((maxcolors>n && n>2), n, maxcolors),
                                 Palname)
        }else{
            if (palname %in% c('rainbow', 'terrain', 'topo', 'heat', 'cm')){
                colObj <- switch(palname,
                                 rainbow=substr(rainbow(n), 1, 7),
                                 terrain=substr(terrain.colors(n), 1, 7),
                                 heat=substr(heat.colors(n), 1, 7),
                                 topo=substr(topo.colors(n), 1, 7),
                                 cm=substr(cm.colors(n), 1, 7)
                )
            }else{
                if (palname %in% c('pander')){
                    colObj <- palette_pander(n)
                }else if (palname %in% c('calc')){
                    colObj <- ggthemes:::ggthemes_data$calc$colors
                }else if (palname %in% c('ptol')) {
                    colObj <- ptol_pal()(ifelse(n > 12, 12, n))
                }else if (palname %in% c('excel', "excel_fill", "excel_line",
                                         "excel_new")){
                    palname <- unlist(strsplit(palname, "excel_"))[2]
                    if (is.na(palname)) palname <- 'new'
                    colObj <- ggthemes:::ggthemes_data$excel[[palname]]
                }else if (palname %in% c('economist', 'economist_white',
                                         'economist_stata')){
                    palname <- unlist(strsplit(palname,"economist_"))[2]
                    if (is.na(palname) || palname=='white') {
                        colObj <- ggthemes:::ggthemes_data$economist$fg
                    } else {
                        colObj <- ggthemes:::ggthemes_data$economist$stata$fg
                    }
                }else if (palname %in% c('darkunica', 'hc')){
                    palname <- ifelse(palname == 'hc', 'default', palname)
                    colObj <- ggthemes:::ggthemes_data$hc$palettes[[palname]]
                }else if (palname %in% c('wsj', 'wsj_rgby', 'wsj_red_green',
                                         'wsj_black_green', 'wsj_dem_rep')){
                    palname <- unlist(strsplit(palname,"wsj_"))[2]
                    if (is.na(palname)) palname <- 'colors6'
                    colObj <- ggthemes:::ggthemes_data$wsj$palettes[[palname]]
                }else if (palname %in% c('stata', 'stata1', 'stata1r', 'statamono')){
                    palname <- switch(palname, stata='stata', stata1='s1color',
                                      stata1r='s1rcolor', statamono='mono')
                    if (palname == 'stata'){
                        colObj <- ggthemes:::ggthemes_data$stata$colors
                    }else{
                        colObj <- try(eval(parse(text=paste0(
                            "stata_pal('", palname, "')(15)"))), TRUE)
                    }
                }else if (palname %in% c('few', 'few_dark', 'few_light')){
                    palname <- unlist(strsplit(palname,"few_"))[2]
                    if (is.na(palname)) palname <- "medium"
                    colObj <- ggthemes:::ggthemes_data$few[[palname]]
                }else if (palname %in%
                          c('fivethirtyeight','gdocs', 'colorblind', 'manyeyes',
                            '538')){
                    if (palname == '538') palname <- 'fivethirtyeight'
                    colObj <- ggthemes:::ggthemes_data[[palname]]
                }else if (palname %in%
                          c('tableau20', 'tableau10medium', 'tableaugray', 'tableauprgy',
                            'tableaublrd', 'tableaugnor', 'tableaucyclic', 'tableau10light',
                            'tableaublrd12', 'tableauprgy12', 'tableaugnor12', 'tableau',
                            'tableaucolorblind', 'trafficlight')){
                    palname <- tableau[tableau$nick==palname,"pal"]
                    colObj <- try(eval(parse(text=paste0("tableau_color_pal(palette='",
                                                     palname,"')(20)"))), TRUE)
                }else if (palname %in%
                          c('solarized', 'solarized_red', 'solarized_yellow',
                            'solarized_orange', 'solarized_magenta', 'solarized_violet',
                            'solarized_blue', 'solarized_cyan', 'solarized_green')){
                    palname <- unlist(strsplit(palname,"solarized_"))[2]
                    colObj <- try(eval(parse(text=paste0(
                        "solarized_pal('", ifelse(is.null(palname), 'blue',
                                                  palname), "')(20)"))), TRUE)
                }
            }
        }
    }
    return(as.vector(colObj))
}

#' Get Hex Color Vector
#'
#' Get color vector from a palette/color name. It is wider than \code{\link{getColFromPal}}.
#' @param palette Palette, default NULL. Could be
#' \itemize{
#'  \item palette name, e.g, "Blues". The palette will be proceeded by \code{\link{getColFromPal}}.
#'  \item a hex color, e.g., "#FFFFFF", "0xFFFFFFFF"
#'  \item a vector or color names, hex colors
#'  \item NULL
#' }
#' @param ... Elipsis
#'
#' @return A vector of hex colors
#'
#' @seealso \code{\link{getColFromPal}} \code{\link{RColorBrewer}} \code{\link{ggthemes}}
#' @examples
#' \dontrun{
#' show_col(recharts:::getColors(NULL))
#' show_col(recharts:::getColors("terrain"))
#' show_col(recharts:::getColors(c('red', 'gold', 'skyblue')))
#' }
getColors <- function(palette, ...){
    # build a function to extract palette info
    # used for echartR
    if ("n" %in% names(list(...))) n <- list(...)[['n']] else n <- 6
    if (length(palette)==1) {
        if (substr(palette, 1, 1)=="#"){
            if (nchar(palette) == 7 || nchar(palette) == 4) {
                return(palette)
            }else{
                palette <- paste0('0x', substring(palette, seq(2,8,2), seq(3,9,2)))
                palette <- strtoi(palette)
                return(rgba(palette))
            }
        }else{
            palettes <- unlist(strsplit(palette, "[\\(\\)]", perl=TRUE))
            if (length(palettes)==1){
                return(getColFromPal(palettes[1], n))
            }else{
                aetPal <- getColFromPal(palettes[1], as.numeric(palettes[2]))
                if (as.numeric(palettes[2]) < length(aetPal)){
                    return(sample(aetPal, as.numeric(palettes[2])))
                }else{
                    return(aetPal)
                }
            }
        }
    }else if(length(palette)>1){
        .convCol <- function(iPal){
            if (!is(try(col2rgb(iPal), TRUE), "try-error")){
                if (substr(iPal, 1, 1) == "#"){
                    return(toupper(iPal))
                }else{
                    vecCol <- as.vector(col2rgb(iPal))
                    return(rgba(vecCol))
                }
            }
        }
        aetPal <- unlist(lapply(palette, .convCol))
        return(aetPal)
    }else{
        return(getColFromPal(NULL))
    }
}

#' Set \code{Color} Palette of Echarts
#'
#' Set color vector of Echarts. When an echart object is generated, you can modify
#' it by setting toolbox using \%>\%.
#' @param chart \code{echart} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param palname name of the palette. Default NULL to get echarts default. Could be:
#' \itemize{#'
#'  \item \link{RColorBrewer} palettes: Including 'BrBG', 'PiYG', 'PRGn', 'PuOr', 'RdBu',
#'  'RdGy', 'RdYlBu', 'RdYlGn', 'Spectral', 'Accent', 'Dark2', 'Paired', 'Pastel1',
#'  'Pastel2', 'Set1', 'Set2', 'Set3', 'Blues', 'BuGn', 'BuPu', 'GnBu', 'Greens',
#'  'Greys', 'Oranges', 'OrRd', 'PuBu', 'PuBuGn', 'PuRd', 'Purples', 'RdPu', 'Reds',
#'  'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd' \cr
#'  \item \link{ggthemes} palettes: 'calc', 'economist', 'economist_white', 'economist_stata',
#'  'excel', 'exel_fill', 'excel_line', 'excel_new', 'few', 'fivethirtyeight', '538', 'manyeyes',
#'  'gdocs', 'pander', 'tableau', 'stata', 'stata1','stata1r','statamono', 'ptol',
#'  'tableau20', 'tableau10medium', 'tableaugray', 'tableauprgy', 'tableaublrd',
#'  'tableaugnor', 'tableaucyclic', 'tableau10light', 'tableaublrd12', 'tableauprgy12',
#'  'tableaugnor12','hc','darkunica', 'solarized','solarized_red', 'solarized_yellow',
#'  'solarized_orange','solarized_magenta','solarized_violet', 'solarized_blue',
#'  'solarized_cyan', 'solarized_green', 'wsj', 'wsj_rgby', 'wsj_red_green',
#'  'wsj_black_green', 'wsj_dem_rep', 'colorblind', 'trafficlight' \cr
#'  \item Aetna official palettes: Including 'aetnagreen', 'aetnablue', 'aetnaviolet',
#'  'aetnaorange', 'aetnateal', 'aetnacranberry' \cr
#'  \item Other palettes: 'rainbow', 'terrain', 'topo', 'heat', 'cm'
#' }
#' Usage: \cr
#' \itemize{
#'  \item Do not set the value and function defaults will be loaded \cr
#'  \item Set palette=NULL to use Echarts defaults \cr
#'  \item Set palette=palette name to assign any palette listed above \cr
#'  \item Set palette=\code{palette name(number)} to restrict number of colors within the
#'  palette (e.g., \code{palette='calc(3)'} picks 3 colors out of 'calc' \strong{RANDOMLY}) \cr
#'  \item Set palette=\code{c(color1, color2, color3, ...)} to define a palette vector,
#'  made of which either color names or Hex expressions. Use \code{\link{colors}()} to check
#'  available color names and check the effects using \code{demo(colors)}.
#' }
#' @param ... Elipsis
#'
#' @return A modified echarts object
#' @export
#'
#' @examples
#' \dontrun{
#' g <- echartR(iris, x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setColor('hc')
#' g %>% setColor(c('red', 'gold', 'deepskyblue'))
#' }
setColor <- function(chart, palette, ...){
    stopifnot(inherits(chart, 'echarts'))
    if ('timeline' %in% names(chart$x)){
        nSeries <- sapply(chart$x$options, function(lst) return(length(lst$series)))
        nSeries <- max(nSeries)
        lstColor <- as.list(getColors(palette, n=nSeries))
        chart$x$options[[1]][['color']] <- lstColor[1:nSeries]
    }else{
        nSeries <- length(chart$x$series)
        lstColor <- as.list(getColors(palette, n=nSeries))
        chart$x[['color']] <- lstColor[1:nSeries]
    }
    return(chart)
}


makeDataZoom <- function(show=FALSE, pos=6, range=NULL, pos.adjust=0,
                         fill='rgba(144,197,237,0.2)',
                         handle='rgba(70,130,180,0.8)', ...){
    # Work function for setDataZoom
    if (!is.null(show)) {
        lstdataZoom <- list(show=show, fillerColor=fill, handleColor=handle)
        if (pos %in% c(8:10)){
            lstdataZoom[['x']] <- 0
        }else if (pos %in% c(11:12, 1, 5:7)){
            lstdataZoom[['x']] <- 80
        }else if (pos %in% c(2:4)){
            lstdataZoom[['x']] <- dev.size('px')[1] - 80
        }
        if (pos %in% c(8:10, 2:4)){
            lstdataZoom[['y']] <- 60
        }else if (pos %in% c(11:12, 1)){
            lstdataZoom[['y']] <- 30
        }
        if (pos.adjust != 0) lstdataZoom[['y']] <- dev.size('px')[2] - pos.adjust
        lstdataZoom[['orient']] <- vecPos(pos)[3]
        if (!is.null(range))
            range <- c(range[1], ifelse(length(range) == 1, range[1], range[2]))
        if (all(is.numeric(range[1:2]))){
            if (any(! range >= 0 | ! range <= 100)){
                stop("dataZoom should be between 0 and 100")
            }else{
                lstdataZoom[['start']] <- min(range[1:2])
                lstdataZoom[['end']] <- max(range[1:2])
            }
        }
    } else {
        lstdataZoom <- list(show=FALSE)
    }
    return(lstdataZoom)
}

#' Set \code{dataZoom} Bar of Echarts
#'
#' When an echart object is generated, you can modify it by setting toolbox using \%>\%.
#'
#' @param chart \code{echart} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show logical. Show the dataZoom control if TRUE.
#' @param pos the clock-position of dataZoom, refert to \code{\link{vecPos}}
#' @param range A vector of \code{c(min, max)}. Cannot be out of the frame c(0, 100)
#' @param pos.adjust Pixel value of the vertical position adjustment from the page edge.
#' @param fill fillerColor of the dataZoom bar, in character \code{'rgba(red, green,
#' blue, alpha)'} format. Default 'rgba(144,197,237,0.2)' ("#90C5ED33").
#' @param handle handleColor of the dataZoom bar, in character \code{'rgba(red, green,
#' blue, alpha)'} format. Default 'rgba(70,130,180,0.8)' ("#4682B4CC").
#' @param ... Elipsis
#'
#' @return A modified echart object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~dataZoom}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setDataZoom(fill=rgba(c(col2rgb('gold'), 0.3)),
#'                   handle=rgba(c(col2rgb('gold'), 1)))
#'
#' g1 <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, z=Species, type='scatter')
#' g1 %>% setDataZoom(fill=rgba(c(col2rgb('lightgreen'), 0.2)),
#'                   handle=rgba(c(col2rgb('darkgreen'), 0.5)))
#' }
setDataZoom <- function(chart, show=TRUE, pos=6, range=NULL, pos.adjust=0,
                        fill='rgba(144,197,237,0.2)',
                        handle='rgba(70,130,180,0.8)', ...){
    stopifnot(inherits(chart, 'echarts'))
    if ('timeline' %in% names(chart$x)){
        chart$x$options[[1]][['dataZoom']] <- makeDataZoom(
            show=show, pos=pos, range=range, pos.adjust=pos.adjust, fill=fill,
            handle=handle)
    }else{
        chart$x[['dataZoom']] <- makeDataZoom(
            show=show, pos=pos, range=range, pos.adjust=pos.adjust, fill=fill,
            handle=handle)
    }
    return(chart)
}

makeDataRange <- function(show=FALSE, pos=8, min=NULL, max=NULL, splitNumber=5,
                          itemGap=5, labels=NULL, calculable=FALSE,
                          borderColor='#ccc', borderWidth=0,
                          selectedMode=list(TRUE, 'single', 'multiple'),
                          color=c("#1e90ff", "#f0ffff"),
                          splitList=NULL, initialRange=NULL, ...){
    # Work function for setDataRange
    ## color must be color vector
    ## splitList must be list(list(start=m, end=n, label=x, color=hex), ...)
    ## initialRange must be list(start=m, end=n)
    if (is.null(show)) {
        lstdataRange <- NULL
    } else {
        if (! show){
            lstdataRange <- NULL
        }else{
            lstdataRange <- list(
                show=show, calculable=ifelse(as.numeric(splitNumber[1])==0 ||
                                                 is.null(splitNumber),
                                             calculable, FALSE),
                color=color, min=min, max=max,
                itemWidth=6, selectedMode=selectedMode[[1]]
            )
            lstdataRange[c('x', 'y', 'orient')] <- vecPos(pos)
            if (borderColor != '#ccc') lstdataRange[['borderColor']] <- borderColor
            if (borderWidth > 0) lstdataRange[['borderWidth']] <- borderWidth

            if (!is.null(labels)) {
                if (length(labels) == 1) lstdataRange[['text']] <- c(labels, "")
                else lstdataRange[['text']] <- labels[1:2]
            }
            if (!is.null(min)) lstdataRange[['min']] <- as.numeric(min)
            if (!is.null(max)) lstdataRange[['max']] <- as.numeric(max)
            if (!is.null(splitList)){
                if (is.list(splitList) &&
                    all(names(splitList[[1]]) %in% c('start', 'end', 'label', 'color'))){
                    lstdataRange[['splitList']] <- splitList
                    lstdataRange[['itemGap']] <- itemGap
                }
            }else{
                if (splitNumber > 0) {
                    lstdataRange[['itemGap']] <- itemGap
                    lstdataRange[['splitNumber']] <- splitNumber
                }
            }
            if (calculable && !is.null(initialRange)){
                if (is.list(initialRange) &&
                    all(names(initialRange) %in% c('start', 'end'))){
                    lstdataRange[['range']] <- initialRange
                }
            }
        }
    }
    return(lstdataRange)
}

#' Set \code{dataRange} Bar of Echarts
#'
#' When an echart object is generated, you can modify it by setting toolbox using \%>\%.
#'
#' @param chart \code{echart} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show logical. Show the dataRange control if TRUE.
#' @param pos the clock-position of dataRange, default 8. Refer to \code{\link{vecPos}}
#' @param valueRange The range of the dataRange bar in form of \code{c(min, max)}.
#' If NULL, echarts default will be used.
#' @param splitNumber How many discrete sections will the dataRange bar be divided into.
#' Default 5. Set it to 0 to set the bar continuous.
#' @param itemGap The gap between itmes in pixels. Default 10px.
#' @param labels The labels to the ends the dataRange bar in form \code{c('high end',
#' 'low end')}. Default NULL, the min, max values will be used.
#' @param borderColor The border color of the dataRange bar. Default '#333'.
#' @param borderWidth The border width of the dataRange bar. Default 0px (not shown).
#' @param calculable Logical. If echart calculable feature is open. Default FALSE.
#' @param selectedMode The mode of the dataRange bar, default TRUE. You can also
#' set it 'single' or 'multiple'.
#' @param color The hex vector of colors used for dataRange bar. Default c("#1e90ff", "#f0ffff").
#' @param splitList A list for user-defined value split in the form of
#' \code{list(list(start=m, end=n, label=x, color=hex), ...)}. If a valid splitList is set,
#' splitNumber will be disabled.
#' @param initialRange Initial selected value range in the form of \code{list(start=m, end=n)}
#' @param ... Elipsis
#'
#' @return A modified echarts object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~dataRange}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setDataRange()
#'
#' g1 <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, z=Species, type='scatter')
#' g1 %>% setDataRange(valueRange=c(0, 2.5))
#' }
setDataRange <- function(
    chart, show=TRUE, pos=8, valueRange=NULL, splitNumber=5, itemGap=5,
    labels=NULL, calculable=FALSE, borderColor='#ccc', borderWidth=0,
    selectedMode=list(TRUE, 'single', 'multiple'),
    color=c("#1e90ff", "#f0ffff"), splitList=NULL, initialRange=NULL,
    ...){
    stopifnot(inherits(chart, 'echarts'))
    if (! is.null(valueRange[1])) {
        if (is.numeric(valueRange) && length(valueRange) > 1){
            min <- range(valueRange)[1]
            max <- range(valueRange)[2]
        }else{
            min <- max <- NULL
        }
    }else{
        min <- range(getYFromEChart(chart))[1]
        max <- range(getYFromEChart(chart))[2]
    }

    lst <- makeDataRange(
        show=show, pos=pos, min=min, max=max, splitNumber=splitNumber,
        itemGap=itemGap, labels=labels, calculable=calculable,
        borderColor=borderColor, borderWidth=borderWidth, selectedMode=selectedMode,
        color=color, splitList=splitList, initialRange=initialRange
    )
    if (!is.null(lst)){
        if ('timeline' %in% names(chart$x)){
            chart$x$options[[1]][['dataRange']] <- lst
        } else {
            chart$x[['dataRange']] <- lst
        }
    }
    return(chart)
}

getYFromEChart <- function(chart, ...){
    ## get y series data and extract the unique values vector
    stopifnot(inherits(chart, 'echarts'))
    .getY <- function(seriesData){
        if (! is.null(dim(seriesData))){
            if (dim(seriesData)[2] > 1){
                return(seriesData[,2])
            }else{
                return(seriesData[,1])
            }
        }else{
            return(seriesData)
        }
    }
    if ('timeline' %in% names(chart$x)){
        y <- sapply(chart$x$options, function(lst){
            Ys <- sapply(lst$series, function(l) {
                return(.getY(l$data))
            })
            return(Ys)
        })
    }else{
        y <- sapply(chart$x$series, function(lst) {
            return(.getY(lst$data))
        })
    }
    return(as.numeric(unique(unlist(y))))
}

#' Set \code{symbolList} of Echarts
#'
#' When an echart object is generated, you can modify it by setting toolbox using \%>\%.
#' You can modify symbolList of the echarts object using this function.
#' @param chart \code{echart} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param symbolList A vector assigning symbols. You can use an array of symbols.
#' If the the symbols array is shorter than the levels of the series in length,
#' the last symbol will be used to extend the array.
#' \itemize{
#'  \item If you set symbolList NULL or
#' leave it unset, the function circulates the default symbol list of Echarts:
#' \code{c('circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle', 'emptyRectangle',
#' 'emptyTriangle', 'emptyDiamond')}. \cr
#'  \item You can also assign non-standard symbols,
#' such as \code{'heart', 'droplet', 'pin', 'arrow', 'star5', 'star6', 'star7', 'star8'}, etc. \cr
#'  \item When assigned to \strong{'none', no symbols are shown}, you can thus yield lines
#' without points on it.  \cr
#'  \item The elements not in the above eligible symbols list will be eliminated.
#' }
#' @param ... Elipsis.
#'
#' @return A modified echarts object.
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~symbolList}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setSymbolList('emptyCircle')
#' g %>% setSymbolList(c('heart', 'pin'))
#' }
setSymbolList <- function(chart, symbolList=NULL, ...){
    validSymbols <- c('circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle',
                      'emptyRectangle', 'emptyTriangle', 'emptyDiamond', 'heart',
                      'droplet', 'pin', 'arrow', 'star5', 'star6', 'star7', 'star8',
                      'none')
    stopifnot(inherits(chart, 'echarts'))
    if (!is.null(symbolList)) {
        symbolList <- symbolList[symbolList %in% validSymbols]
        if (length(symbolList) > 0) {
            if ('timeline' %in% names(chart$x)){
                nlvlseries <- sapply(chart$x$options, function(lst) {
                    length(lst$series)})
                nlvlseries <- max(unlist(nlvlseries))
                if (length(symbolList) < nlvlseries)
                    symbolList <- c(symbolList,
                                    rep(symbolList[length(symbolList)],
                                        nlvlseries-length(symbolList)))
                chart$x$options[[1]][['symbolList']] <- symbolList
            }else{
                nlvlseries <- length(chart$x$series)
                if (length(symbolList) < nlvlseries)
                    symbolList <- c(symbolList,
                                    rep(symbolList[length(symbolList)],
                                        nlvlseries-length(symbolList)))
                chart$x[['symbolList']] <- symbolList
            }
        }
    }
    return(chart)

}

getSeriesName <- function(chart, ...){
    ## get variable names vector from an echarts object
    stopifnot(inherits(chart, 'echarts'))
    if ('timeline' %in% names(chart$x)){
        series <- sapply(chart$x$options[[1]]$series, function(lst) lst$name)
    }else{
        series <- sapply(chart$x$series, function(lst) lst$name)
    }
    return(unlist(series))
}

#' Set \code{legend} of Echarts
#'
#' When an echart object is generated, you can modify it by setting toolbox using \%>\%.
#' You can modify the legend of the echarts object using this function.
#' @param chart \code{echart} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show Logical. Show the legend or not. Default TRUE.
#' @param pos Clock position of the legend. Default 11. Refer to \code{\link{vecPos}}.
#' @param selected A vector of series names that are selected on load. If you assign 'none',
#' then none of the series will be selected in the beginning.
#' @param itemGap The gap between legend items. Default 5px.
#' @param borderColor The border color of the legend. Default '#ccc'.
#' @param borderWidth The border width of the legend. Default 0px (not shown).
#' @param textStyle A list of textStyle definition to decorate the text. E.g.,
#' \code{list(color='#444')} or \code{list(color='auto')}.
#' @param formatter A named formatter template or a string containing javascript codes.
#' E.g., \code{'{name}'}.
#' @param overideData A list of data to overide the legend text. E.g.,
#' \code{list(list(name='Series 1', icon='image://../asset/ico/favicon.png',
#' textStyle=list(color='#bbb')))}
#' @param ... Elipsis.
#'
#' @return A modified echarts object.
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~legend}
#' @examples
#' \donrun{
#' # No timeline
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setLegend(selected="versicolor")
#' g %>% setLegend(selected=levels(iris$Species)[1:2],
#'                 textStyle=list(fontFamily='Times New Roman', color='purple',
#'                                fontWeight='bold', fontSize=16))
#'
#' # Timeline
#' g1 <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, z=Species, type='scatter')
#' g1 %>% setLegend(pos=12, selected='none',
#'                  textStyle=list(fontFamily='Courier New', fontSize=16))
#' }
setLegend <- function(
    chart, show=TRUE, pos=11, selected=NULL, itemGap=5, borderColor='#ccc',
    borderWidth=0, textStyle=list(color='auto'), formatter=NULL, overideData=NULL,
    ...){
    stopifnot(inherits(chart, 'echarts'))

    series <- getSeriesName(chart)  # get series name vector from echarts object
    lstLegend <- list(show=show, data=as.list(series))
    lstLegend[c('x', 'y', 'orient')] <- vecPos(pos)
    if (!is.null(selected)){
        unselected <- series[! series %in% selected]
        lstLegend[['selected']] <- emptyList()
        for (item in unselected){
            lstLegend[['selected']][[item]] <- FALSE
        }
        if (length(selected) != length(series)){
            if (length(selected) == 1) lstLegend[['selectedMode']] <- 'single'
            else lstLegend[['selectedMode']] <- 'multiple'
        }
    }
    if (borderColor != '#ccc') lstLegend[['borderColor']] <- borderColor
    if (borderWidth > 0) lstLegend[['borderWidth']] <- borderWidth

    if (is.list(textStyle) && !identical(textStyle, list(color='auto')))
        if (all(names(textStyle) %in% c('fontFamily', 'color', 'fontSize',
                                        'fontStyle', 'fontWeight')))
            lstLegend[['textStyle']] <- textStyle
    if (!is.null(formatter) && is.list(formatter))
        lstLegend[['formatter']] <- formatter
    if (!is.null(overideData) && is.list(overideData))
        if (all(names(overideData) %in% c('name', 'textStyle', 'icon')))
            lstLegend[['data']] <- overideData

    if (! is.null(show)) {
        if ('timeline' %in% names(chart$x)){
            chart$x$options[[1]][['legend']] <- lstLegend
        }else{
            chart$x[['legend']] <- lstLegend
        }
    }
    return(chart)
}

tooltipJS <- function(type) {
    # tooltipJS templates for echarts
    switch(
        type,
        time = 'function (params) {
        var date = new Date(params.value[0]);
        data = date.getFullYear() + "-"
        + (date.getMonth() + 1) + "-"
        + date.getDate() + " "
        + date.getHours() + ":"
        + date.getMinutes();
        if (param.value.length > 2) {
        return data + "<br/>"
        + params.value[1] + ", "
        + params.value[2];
        } else {
        return data + "<br/>"
        + params.value[1];
        }
}',
           scatter = 'function (params) {
        if (params.value.length > 1) {
        return params.seriesName + " :<br/>"
        + params.value[0] + " ,    " +
        + params.value[1];
        } else {
        return params.seriesName + " :<br/>"
        + params.name + " : "
        + params.value;
        }
           }',
           chord_mono = 'function (params) {
        if (params.name && params.name.indexOf("-") != -1) {
        return params.name.replace("-", " " + params.seriesName + " ")
        }
        else {
        return params.name ? params.name : params.data.id
        }
           }',
           chord_multi = 'function (params) {
        if (params.indicator2) {    // is edge
        return params.indicator2 + " " +
        params.name + " " + params.indicator + " : " +
        params.value.weight;
        } else {    // is node
        return params.name
        }
           }',
           pie = '{a} <br/>{b} : {c} ({d}%)',
        k = 'function (params) {
        var res = params[0].name;
        res += "<br/>  Open : " + params[0].value[0] +
        "  High : " + params[0].value[3];
        res += "<br/>  Close : " + params[0].value[1] +
        "  Low : " + params[0].value[2];
        return res;
        }',
           hist = 'function (params){
        return params.value[2] + "<br/>Count:" +
        params.value[1];
           }'
           )
    }
